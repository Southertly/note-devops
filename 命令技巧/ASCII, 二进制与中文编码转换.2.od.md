# ASCII, 二进制与中文编码转换.2.od

参考文章

1. [在bash中，我怎样才能从二进制转换为utf8？](https://cloud.tencent.com/developer/ask/138070)
    - `sed -E 's/.*:(( [01]+){0,6}).*/\1/'`: 截取`:`前后的有效的二进制字符串
    - `sed -E 's/ ([01]+)/ $((2#\1))/g'`: 借助双小括号`(())`将二进制字符串转换成10进制.
2. [How to print first 10 bytes in hexadecimal of a file?](https://superuser.com/questions/706101/how-to-print-first-10-bytes-in-hexadecimal-of-a-file)
    - 打印一个文件的前10个字节, 对于分析不同格式的文件的文件头时应该十分有用.

## 编码转换

```bash
echo -n abcdefghijklmnoprs | od -tx
## 0000000 64636261 68676665 6c6b6a69 706f6e6d
## 0000020 00007372
## 0000022
```

`od`的输出将会像一些工具(比如winhex, 或是wireshark)中的16进制查看区域一样进行排列, 默认一行16个(可使用`-w`选项调整). 第一列是地址列, 起始为`000000`(这一点和`xxd`很像), 最后一行为空行, 且该行的第一列表示结束地址.

## `-A`起始地址

与`xxd`一样, 我们也经常只需要纯输出, 不需要显示地址(或者说偏移量).

```bash
echo -n abcdefghijklmnoprs | od -tx -An
## 64636261 68676665 6c6b6a69 706f6e6d
## 00007372
```

`-A`/`--address-radix`: 表示的其实是第1列的地址显示格式, 因为每行的字节数默认是16, 所以每行的地址列显示的都是16的倍数(除了最后一行)
    - `n`: 表示不显示第1列的地址(上面已给出示例)
    - `d`: 十进制. 上面的命令第1列的输出分别为`0000000`, `0000016`, `0000018`
    - `o`: 八进制(默认). 上面的命令第1列的输出分别为`0000000`, `0000020`, `0000022`
    - `x`: 十六进制. 上面的命令第1列的输出分别为`000000`, `000010`, `000012`.

## `-t`/`--format`输出格式

`-t`表示要输出的格式, 可选的有(可指定多个, 这样每行输入都会有多行不同格式的输出, 作为对比打印出来)
    - `a`: ASCII, 不可见字符将以指定的名称显示, 比如换行将显示为`nl`)
    - `c`: 默认字符集中的字符, 如果指定了这个标记, 换行将直接显示为`\n`, 更直观.
    - 按指定进行显示各字节, 这一类包含: `d`(十进制), `o`(八进制), `u`(无符号十进制...???我call), `x`(十六进制). man手册还规定, 使用此类显示方式时, 可以指定各字节的组合长度, 默认是4个字节为一组(比如上面的`-tx`). 组合长度可选的有`C`(char单字节), `S`(short双字节), `I`(int四字节), `L`(long八字节), 也可以手动指定ta们(C|S|I|L)的数字表示(1, 2, 4, 8)比如`-tx4`.

```bash
## 这是换行实例
echo | od -An -ta   ## nl
echo | od -An -tc   ## \n
echo | od -An -txC  ## 0a
```

```bash
echo -n 中国 | od -An -ta   ##    d   8   -   e esc   =
echo -n 中国 | od -An -tc   ##  344 270 255 345 233 275
echo -n 中国 | od -An -txC  ##  e4 b8 ad e5 9b bd
```
